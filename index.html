<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algo the Rithm</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #1e1e2f;
      color: #fff;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header {
      padding: 20px;
      text-align: center;
    }

    #controls {
      margin-bottom: 20px;
    }

    button, select {
      padding: 10px;
      margin: 0 5px;
      background-color: #3b3b5b;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #container, #compareContainer {
      display: flex;
      align-items: flex-end;
      height: 300px;
      width: 90vw;
      max-width: 1000px;
      margin: 20px 0;
    }

    .bar {
      flex: 1;
      margin: 0 1px;
      background-color: steelblue;
    }

    table {
      border-collapse: collapse;
      margin: 20px;
      background: #2c2c3d;
      color: white;
    }

    th, td {
      padding: 10px 15px;
      border: 1px solid #444;
    }
  </style>
</head>
<body>
  <header>
    <h1>Algo the Rithm</h1>
    <div id="controls">
      <select id="algorithm">
        <option value="bubble">Bubble Sort</option>
        <option value="insertion">Insertion Sort</option>
        <option value="selection">Selection Sort</option>
        <option value="merge">Merge Sort</option>
        <option value="quick">Quick Sort</option>
        <option value="heap">Heap Sort</option>
        <option value="shell">Shell Sort</option>
      </select>
      <button onclick="startSort()">Sortieren</button>
      <button onclick="shuffleArray()">Neu mischen</button>
      <button onclick="compareSorts()">Vergleich starten</button>
    </div>
  </header>

  <div id="container"></div>
  <div id="compareContainer"></div>

  <table>
    <thead>
      <tr>
        <th>Algorithmus</th>
        <th>Zeit (ms)</th>
      </tr>
    </thead>
    <tbody id="results">
      <!-- Ergebnisse werden hier eingetragen -->
    </tbody>
  </table>

  <script>
    const container = document.getElementById('container');
    const compareContainer = document.getElementById('compareContainer');
    const resultsTable = document.getElementById('results');
    const arraySize = 100;
    let array = [];

    function generateArray() {
      array = Array.from({ length: arraySize }, () => Math.floor(Math.random() * 300) + 10);
    }

    function render(arr, element) {
      element.innerHTML = '';
      arr.forEach(height => {
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.height = `${height}px`;
        element.appendChild(bar);
      });
    }

    function shuffleArray() {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      render(array, container);
    }

    async function bubbleSort(arr, renderTarget) {
      let n = arr.length;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n - i - 1; j++) {
          if (arr[j] > arr[j + 1]) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            render(arr, renderTarget);
            await new Promise(r => setTimeout(r, 10));
          }
        }
      }
    }

    async function insertionSort(arr, renderTarget) {
      for (let i = 1; i < arr.length; i++) {
        let key = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > key) {
          arr[j + 1] = arr[j];
          j--;
          render(arr, renderTarget);
          await new Promise(r => setTimeout(r, 10));
        }
        arr[j + 1] = key;
        render(arr, renderTarget);
        await new Promise(r => setTimeout(r, 10));
      }
    }

    async function selectionSort(arr, renderTarget) {
      for (let i = 0; i < arr.length; i++) {
        let minIdx = i;
        for (let j = i + 1; j < arr.length; j++) {
          if (arr[j] < arr[minIdx]) {
            minIdx = j;
          }
        }
        if (minIdx !== i) {
          [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
          render(arr, renderTarget);
          await new Promise(r => setTimeout(r, 10));
        }
      }
    }

    async function mergeSort(arr, renderTarget, start = 0) {
      if (arr.length < 2) return arr;
      const mid = Math.floor(arr.length / 2);
      const left = await mergeSort(arr.slice(0, mid), renderTarget, start);
      const right = await mergeSort(arr.slice(mid), renderTarget, start + mid);
      const merged = await merge(left, right, renderTarget, start);
      return merged;
    }

    async function merge(left, right, renderTarget, start) {
      let result = [], i = 0, j = 0;
      while (i < left.length && j < right.length) {
        result.push(left[i] < right[j] ? left[i++] : right[j++]);
        render([...array.slice(0, start), ...result, ...left.slice(i), ...right.slice(j), ...array.slice(start + result.length + (left.length - i) + (right.length - j))], renderTarget);
        await new Promise(r => setTimeout(r, 10));
      }
      const merged = [...result, ...left.slice(i), ...right.slice(j)];
      for (let k = 0; k < merged.length; k++) {
        array[start + k] = merged[k];
      }
      render(array, renderTarget);
      await new Promise(r => setTimeout(r, 10));
      return merged;
    }

    async function quickSort(arr, renderTarget, left = 0, right = arr.length - 1) {
      if (left < right) {
        let pivotIndex = await partition(arr, renderTarget, left, right);
        await quickSort(arr, renderTarget, left, pivotIndex - 1);
        await quickSort(arr, renderTarget, pivotIndex + 1, right);
      }
    }

    async function partition(arr, renderTarget, left, right) {
      let pivot = arr[right];
      let i = left;
      for (let j = left; j < right; j++) {
        if (arr[j] < pivot) {
          [arr[i], arr[j]] = [arr[j], arr[i]];
          i++;
          render(arr, renderTarget);
          await new Promise(r => setTimeout(r, 10));
        }
      }
      [arr[i], arr[right]] = [arr[right], arr[i]];
      render(arr, renderTarget);
      await new Promise(r => setTimeout(r, 10));
      return i;
    }

    async function heapSort(arr, renderTarget) {
      function heapify(n, i) {
        let largest = i;
        let left = 2 * i + 1;
        let right = 2 * i + 2;

        if (left < n && arr[left] > arr[largest]) largest = left;
        if (right < n && arr[right] > arr[largest]) largest = right;
        if (largest !== i) {
          [arr[i], arr[largest]] = [arr[largest], arr[i]];
          render(arr, renderTarget);
          return new Promise(r => setTimeout(() => heapify(n, largest).then(r), 10));
        }
        return Promise.resolve();
      }

      let n = arr.length;
      for (let i = Math.floor(n / 2) - 1; i >= 0; i--) await heapify(n, i);
      for (let i = n - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]];
        render(arr, renderTarget);
        await new Promise(r => setTimeout(r, 10));
        await heapify(i, 0);
      }
    }

    async function shellSort(arr, renderTarget) {
      let n = arr.length;
      for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {
        for (let i = gap; i < n; i++) {
          let temp = arr[i];
          let j;
          for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
            arr[j] = arr[j - gap];
            render(arr, renderTarget);
            await new Promise(r => setTimeout(r, 10));
          }
          arr[j] = temp;
          render(arr, renderTarget);
          await new Promise(r => setTimeout(r, 10));
        }
      }
    }

    async function sortAlgorithm(name, arr, renderTarget) {
      if (name === 'bubble') return bubbleSort(arr, renderTarget);
      if (name === 'insertion') return insertionSort(arr, renderTarget);
      if (name === 'selection') return selectionSort(arr, renderTarget);
      if (name === 'merge') return mergeSort(arr, renderTarget);
      if (name === 'quick') return quickSort(arr, renderTarget);
      if (name === 'heap') return heapSort(arr, renderTarget);
      if (name === 'shell') return shellSort(arr, renderTarget);
    }

    async function startSort() {
      const selected = document.getElementById('algorithm').value;
      const arrCopy = [...array];
      const start = performance.now();
      await sortAlgorithm(selected, arrCopy, container);
      const end = performance.now();
      resultsTable.innerHTML += `<tr><td>${selected}</td><td>${(end - start).toFixed(2)}</td></tr>`;
    }

    async function compareSorts() {
      const selected = document.getElementById('algorithm').value;
      const arr1 = [...array];
      const arr2 = [...array];

      const start1 = performance.now();
      sortAlgorithm(selected, arr1, container);
      const end1 = performance.now();

      const start2 = performance.now();
      await sortAlgorithm(selected, arr2, compareContainer);
      const end2 = performance.now();

      resultsTable.innerHTML += `
        <tr><td>${selected} (links)</td><td>${(end1 - start1).toFixed(2)}</td></tr>
        <tr><td>${selected} (rechts)</td><td>${(end2 - start2).toFixed(2)}</td></tr>
      `;
    }

    generateArray();
    render(array, container);
  </script>
</body>
</html>